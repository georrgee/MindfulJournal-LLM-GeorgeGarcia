import { jsx as _jsx } from "react/jsx-runtime";
import { composeRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/core";
import { ScrollView } from "@tamagui/scroll-view";
import { useControllableState } from "@tamagui/use-controllable-state";
import React, { useEffect } from "react";
import { useSheetContext } from "./SheetContext";
var SHEET_SCROLL_VIEW_NAME = "SheetScrollView", SheetScrollView = /* @__PURE__ */ React.forwardRef(function(param, ref) {
  var { __scopeSheet, children, onScroll, scrollEnabled: scrollEnabledProp, ...props } = param, context = useSheetContext(SHEET_SCROLL_VIEW_NAME, __scopeSheet), { scrollBridge, scrollEnabled: scrollEnabled_, setHasScrollView } = context, [scrollEnabled, setScrollEnabled_] = useControllableState({
    prop: scrollEnabledProp,
    defaultProp: !0
  }), scrollRef = React.useRef(null), setScrollEnabled = function(next) {
    var _scrollRef_current_setNativeProps, _scrollRef_current;
    (_scrollRef_current = scrollRef.current) === null || _scrollRef_current === void 0 || (_scrollRef_current_setNativeProps = _scrollRef_current.setNativeProps) === null || _scrollRef_current_setNativeProps === void 0 || _scrollRef_current_setNativeProps.call(_scrollRef_current, {
      scrollEnabled: next
    }), setScrollEnabled_(next);
  }, state = React.useRef({
    lastPageY: 0,
    dragAt: 0,
    dys: [],
    // store a few recent dys to get velocity on release
    isScrolling: !1,
    isDragging: !1
  });
  useEffect(function() {
    return setHasScrollView(!0), function() {
      setHasScrollView(!1);
    };
  }, []);
  var release = function() {
    if (state.current.isDragging) {
      state.current.isDragging = !1, scrollBridge.scrollStartY = -1, state.current.isScrolling = !1, setScrollEnabled(!0);
      var vy = 0;
      if (state.current.dys.length) {
        var recentDys = state.current.dys.slice(-10), dist = recentDys.length ? recentDys.reduce(function(a, b) {
          return a + b;
        }, 0) : 0, avgDy = dist / recentDys.length;
        vy = avgDy * 0.04;
      }
      state.current.dys = [], scrollBridge.release({
        dragAt: state.current.dragAt,
        vy
      });
    }
  }, scrollable = scrollEnabled ?? scrollEnabled_;
  return /* @__PURE__ */ _jsx(ScrollView, {
    ref: composeRefs(scrollRef, ref),
    flex: 1,
    scrollEventThrottle: 8,
    onResponderRelease: release,
    className: "_ovs-contain",
    scrollEnabled: scrollable,
    // {...(Platform.OS === 'android' && {
    //   pointerEvents: scrollable ? undefined : 'none',
    // })}
    onScroll: function(e) {
      var { y } = e.nativeEvent.contentOffset;
      scrollBridge.y = y, isWeb && (scrollBridge.scrollLock = y > 0), y > 0 && (scrollBridge.scrollStartY = -1), onScroll == null || onScroll(e);
    },
    // This assures that we do not skip the "scrollBridge" values processing
    // when passing this prop into a <Sheet.ScrollView /> overriding it here
    // Useful when using this ScrollView with lists such as "FlashList", i.e.
    // ```
    // renderScrollComponent={Sheet.ScrollView}
    // ```
    onStartShouldSetResponder: function() {
      return scrollBridge.scrollStartY = -1, state.current.isDragging = !0, scrollable;
    },
    // setting to false while onResponderMove is disabled
    onMoveShouldSetResponder: function(e) {
      return scrollable;
    },
    contentContainerStyle: {
      minHeight: "100%"
    },
    onResponderMove: function(e) {
      if (isWeb) {
        var { pageY } = e.nativeEvent;
        if (state.current.isScrolling) {
          e.stopPropagation();
          return;
        }
        scrollBridge.scrollStartY === -1 && (scrollBridge.scrollStartY = pageY, state.current.lastPageY = pageY);
        var dragAt = pageY - scrollBridge.scrollStartY, dy = pageY - state.current.lastPageY;
        state.current.lastPageY = pageY;
        var isDraggingUp = dy < 0, isPaneAtTop = scrollBridge.paneY <= scrollBridge.paneMinY;
        if ((dy === 0 || isDraggingUp) && isPaneAtTop) {
          state.current.isScrolling = !0, scrollBridge.scrollLock = !0, setScrollEnabled(!0);
          return;
        }
        setScrollEnabled(!1), scrollBridge.drag(dragAt), state.current.dragAt = dragAt, state.current.dys.push(dy), state.current.dys.length > 100 && (state.current.dys = state.current.dys.slice(-10));
      }
    },
    ...props,
    children
  });
});
export {
  SheetScrollView
};
//# sourceMappingURL=SheetScrollView.js.map
