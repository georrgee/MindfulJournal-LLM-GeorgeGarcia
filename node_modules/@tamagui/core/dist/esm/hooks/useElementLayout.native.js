import { isClient, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { isEqualShallow, ___onDidFinishClientRender } from "@tamagui/web";
var LayoutHandlers = /* @__PURE__ */new WeakMap(),
  Nodes = /* @__PURE__ */new Set(),
  strategy = "async";
function setOnLayoutStrategy(state) {
  strategy = state;
}
var NodeRectCache = /* @__PURE__ */new WeakMap(),
  ParentRectCache = /* @__PURE__ */new WeakMap(),
  DebounceTimers = /* @__PURE__ */new WeakMap(),
  LastChangeTime = /* @__PURE__ */new WeakMap(),
  rAF = typeof window < "u" ? window.requestAnimationFrame : void 0,
  DEBOUNCE_DELAY = 32;
if (isClient) if (rAF) {
  let layoutOnAnimationFrame = function () {
    var now = Date.now(),
      timeSinceLastFrame = now - lastFrameAt;
    if (lastFrameAt = now, strategy !== "off") {
      var expectedFrameTime = 16.67,
        hasRecentSyncWork = timeSinceLastFrame > expectedFrameTime * numDroppedFramesUntilPause;
      hasRecentSyncWork || Nodes.forEach(updateLayoutIfChanged);
    }
    rAF(layoutOnAnimationFrame);
  };
  var layoutOnAnimationFrame2 = layoutOnAnimationFrame,
    avoidUpdates = !0,
    queuedUpdates = /* @__PURE__ */new Map(),
    lastFrameAt = Date.now(),
    numDroppedFramesUntilPause = 2;
  ___onDidFinishClientRender(function () {
    avoidUpdates = !1, queuedUpdates && (queuedUpdates.forEach(function (cb) {
      return cb();
    }), queuedUpdates.clear());
  });
  async function updateLayoutIfChanged(node) {
    var nodeRect = node.getBoundingClientRect(),
      parentNode = node.parentElement,
      parentRect = parentNode?.getBoundingClientRect(),
      onLayout = LayoutHandlers.get(node);
    if (typeof onLayout == "function") {
      var cachedRect = NodeRectCache.get(node),
        cachedParentRect = parentNode ? NodeRectCache.get(parentNode) : null;
      if (!cachedRect ||
      // has changed one rect
      !isEqualShallow(cachedRect, nodeRect) && (!cachedParentRect || !isEqualShallow(cachedParentRect, parentRect))) if (NodeRectCache.set(node, nodeRect), parentRect && parentNode && ParentRectCache.set(parentNode, parentRect), avoidUpdates) {
        var event = getElementLayoutEvent(node);
        queuedUpdates.set(node, function () {
          return onLayout(event);
        });
      } else if (strategy === "async") {
        var now = Date.now();
        LastChangeTime.set(node, now);
        var existingTimer = DebounceTimers.get(node);
        existingTimer && clearTimeout(existingTimer);
        var timer = setTimeout(async function () {
          var lastChange = LastChangeTime.get(node) || 0,
            timeSinceChange = Date.now() - lastChange;
          if (timeSinceChange >= DEBOUNCE_DELAY) {
            var event2 = await getElementLayoutEventAsync(node);
            onLayout(event2), DebounceTimers.delete(node);
          } else {
            var remainingDelay = DEBOUNCE_DELAY - timeSinceChange,
              newTimer = setTimeout(async function () {
                var event3 = await getElementLayoutEventAsync(node);
                onLayout(event3), DebounceTimers.delete(node);
              }, remainingDelay);
            DebounceTimers.set(node, newTimer);
          }
        }, DEBOUNCE_DELAY);
        DebounceTimers.set(node, timer);
      } else {
        var event1 = getElementLayoutEvent(node);
        onLayout(event1);
      }
    }
  }
  rAF(layoutOnAnimationFrame);
} else process.env.NODE_ENV === "development" && console.warn("No requestAnimationFrame - please polyfill for onLayout to work correctly");
var getElementLayoutEvent = function (target) {
    var res = null;
    if (measureLayout(target, null, function (x, y, width, height, left, top) {
      res = {
        nativeEvent: {
          layout: {
            x,
            y,
            width,
            height,
            left,
            top
          },
          target
        },
        timeStamp: Date.now()
      };
    }), !res) throw new Error("\u203C\uFE0F");
    return res;
  },
  measureLayout = function (node, relativeTo, callback) {
    var relativeNode = relativeTo || node?.parentElement;
    if (relativeNode instanceof HTMLElement) {
      var nodeDim = node.getBoundingClientRect(),
        relativeNodeDim = relativeNode.getBoundingClientRect();
      if (relativeNodeDim && nodeDim) {
        var {
          x,
          y,
          width,
          height,
          left,
          top
        } = getRelativeDimensions(nodeDim, relativeNodeDim);
        callback(x, y, width, height, left, top);
      }
    }
  },
  getElementLayoutEventAsync = async function (target) {
    var res = null;
    if (await measureLayoutAsync(target, null, function (x, y, width, height, left, top) {
      res = {
        nativeEvent: {
          layout: {
            x,
            y,
            width,
            height,
            left,
            top
          },
          target
        },
        timeStamp: Date.now()
      };
    }), !res) throw new Error("\u203C\uFE0F");
    return res;
  },
  measureLayoutAsync = async function (node, relativeTo, callback) {
    var relativeNode = relativeTo || node?.parentElement;
    if (relativeNode instanceof HTMLElement) {
      var [nodeDim, relativeNodeDim] = await Promise.all([node.getBoundingClientRect(), relativeNode.getBoundingClientRect()]);
      if (relativeNodeDim && nodeDim) {
        var {
          x,
          y,
          width,
          height,
          left,
          top
        } = getRelativeDimensions(nodeDim, relativeNodeDim);
        callback(x, y, width, height, left, top);
      }
    }
  },
  getRelativeDimensions = function (a, b) {
    var {
        height,
        left,
        top,
        width
      } = a,
      x = left - b.left,
      y = top - b.top;
    return {
      x,
      y,
      width,
      height,
      left,
      top
    };
  };
function useElementLayout(ref, onLayout) {
  var _ref_current,
    node = (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.host;
  node && onLayout && LayoutHandlers.set(node, onLayout), useIsomorphicLayoutEffect(function () {
    var _ref_current2;
    if (onLayout) {
      var node2 = (_ref_current2 = ref.current) === null || _ref_current2 === void 0 ? void 0 : _ref_current2.host;
      if (node2) return LayoutHandlers.set(node2, onLayout), Nodes.add(node2), onLayout(getElementLayoutEvent(node2)), function () {
        Nodes.delete(node2), LayoutHandlers.delete(node2), NodeRectCache.delete(node2);
        var timer = DebounceTimers.get(node2);
        timer && (clearTimeout(timer), DebounceTimers.delete(node2)), LastChangeTime.delete(node2);
      };
    }
  }, [ref, !!onLayout]);
}
export { getElementLayoutEvent, getElementLayoutEventAsync, measureLayout, measureLayoutAsync, setOnLayoutStrategy, useElementLayout };
//# sourceMappingURL=useElementLayout.native.js.map
