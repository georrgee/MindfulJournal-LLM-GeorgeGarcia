import { isClient, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { isEqualShallow, ___onDidFinishClientRender } from "@tamagui/web";
const LayoutHandlers = /* @__PURE__ */new WeakMap(),
  Nodes = /* @__PURE__ */new Set();
let strategy = "async";
function setOnLayoutStrategy(state) {
  strategy = state;
}
const NodeRectCache = /* @__PURE__ */new WeakMap(),
  ParentRectCache = /* @__PURE__ */new WeakMap(),
  DebounceTimers = /* @__PURE__ */new WeakMap(),
  LastChangeTime = /* @__PURE__ */new WeakMap(),
  rAF = typeof window < "u" ? window.requestAnimationFrame : void 0,
  DEBOUNCE_DELAY = 32;
if (isClient) if (rAF) {
  let layoutOnAnimationFrame = function () {
      const now = Date.now(),
        timeSinceLastFrame = now - lastFrameAt;
      lastFrameAt = now, strategy !== "off" && (timeSinceLastFrame > 16.67 * numDroppedFramesUntilPause || Nodes.forEach(updateLayoutIfChanged)), rAF(layoutOnAnimationFrame);
    },
    avoidUpdates = !0;
  const queuedUpdates = /* @__PURE__ */new Map();
  let lastFrameAt = Date.now();
  const numDroppedFramesUntilPause = 2;
  ___onDidFinishClientRender(() => {
    avoidUpdates = !1, queuedUpdates && (queuedUpdates.forEach(cb => cb()), queuedUpdates.clear());
  });
  async function updateLayoutIfChanged(node) {
    const nodeRect = node.getBoundingClientRect(),
      parentNode = node.parentElement,
      parentRect = parentNode?.getBoundingClientRect(),
      onLayout = LayoutHandlers.get(node);
    if (typeof onLayout != "function") return;
    const cachedRect = NodeRectCache.get(node),
      cachedParentRect = parentNode ? NodeRectCache.get(parentNode) : null;
    if (!cachedRect ||
    // has changed one rect
    !isEqualShallow(cachedRect, nodeRect) && (!cachedParentRect || !isEqualShallow(cachedParentRect, parentRect))) if (NodeRectCache.set(node, nodeRect), parentRect && parentNode && ParentRectCache.set(parentNode, parentRect), avoidUpdates) {
      const event = getElementLayoutEvent(node);
      queuedUpdates.set(node, () => onLayout(event));
    } else if (strategy === "async") {
      const now = Date.now();
      LastChangeTime.set(node, now);
      const existingTimer = DebounceTimers.get(node);
      existingTimer && clearTimeout(existingTimer);
      const timer = setTimeout(async () => {
        const lastChange = LastChangeTime.get(node) || 0,
          timeSinceChange = Date.now() - lastChange;
        if (timeSinceChange >= DEBOUNCE_DELAY) {
          const event = await getElementLayoutEventAsync(node);
          onLayout(event), DebounceTimers.delete(node);
        } else {
          const remainingDelay = DEBOUNCE_DELAY - timeSinceChange,
            newTimer = setTimeout(async () => {
              const event = await getElementLayoutEventAsync(node);
              onLayout(event), DebounceTimers.delete(node);
            }, remainingDelay);
          DebounceTimers.set(node, newTimer);
        }
      }, DEBOUNCE_DELAY);
      DebounceTimers.set(node, timer);
    } else {
      const event = getElementLayoutEvent(node);
      onLayout(event);
    }
  }
  rAF(layoutOnAnimationFrame);
} else process.env.NODE_ENV === "development" && console.warn("No requestAnimationFrame - please polyfill for onLayout to work correctly");
const getElementLayoutEvent = target => {
    let res = null;
    if (measureLayout(target, null, (x, y, width, height, left, top) => {
      res = {
        nativeEvent: {
          layout: {
            x,
            y,
            width,
            height,
            left,
            top
          },
          target
        },
        timeStamp: Date.now()
      };
    }), !res) throw new Error("\u203C\uFE0F");
    return res;
  },
  measureLayout = (node, relativeTo, callback) => {
    const relativeNode = relativeTo || node?.parentElement;
    if (relativeNode instanceof HTMLElement) {
      const nodeDim = node.getBoundingClientRect(),
        relativeNodeDim = relativeNode.getBoundingClientRect();
      if (relativeNodeDim && nodeDim) {
        const {
          x,
          y,
          width,
          height,
          left,
          top
        } = getRelativeDimensions(nodeDim, relativeNodeDim);
        callback(x, y, width, height, left, top);
      }
    }
  },
  getElementLayoutEventAsync = async target => {
    let res = null;
    if (await measureLayoutAsync(target, null, (x, y, width, height, left, top) => {
      res = {
        nativeEvent: {
          layout: {
            x,
            y,
            width,
            height,
            left,
            top
          },
          target
        },
        timeStamp: Date.now()
      };
    }), !res) throw new Error("\u203C\uFE0F");
    return res;
  },
  measureLayoutAsync = async (node, relativeTo, callback) => {
    const relativeNode = relativeTo || node?.parentElement;
    if (relativeNode instanceof HTMLElement) {
      const [nodeDim, relativeNodeDim] = await Promise.all([node.getBoundingClientRect(), relativeNode.getBoundingClientRect()]);
      if (relativeNodeDim && nodeDim) {
        const {
          x,
          y,
          width,
          height,
          left,
          top
        } = getRelativeDimensions(nodeDim, relativeNodeDim);
        callback(x, y, width, height, left, top);
      }
    }
  },
  getRelativeDimensions = (a, b) => {
    const {
        height,
        left,
        top,
        width
      } = a,
      x = left - b.left,
      y = top - b.top;
    return {
      x,
      y,
      width,
      height,
      left,
      top
    };
  };
function useElementLayout(ref, onLayout) {
  const node = ref.current?.host;
  node && onLayout && LayoutHandlers.set(node, onLayout), useIsomorphicLayoutEffect(() => {
    if (!onLayout) return;
    const node2 = ref.current?.host;
    if (node2) return LayoutHandlers.set(node2, onLayout), Nodes.add(node2), onLayout(getElementLayoutEvent(node2)), () => {
      Nodes.delete(node2), LayoutHandlers.delete(node2), NodeRectCache.delete(node2);
      const timer = DebounceTimers.get(node2);
      timer && (clearTimeout(timer), DebounceTimers.delete(node2)), LastChangeTime.delete(node2);
    };
  }, [ref, !!onLayout]);
}
export { getElementLayoutEvent, getElementLayoutEventAsync, measureLayout, measureLayoutAsync, setOnLayoutStrategy, useElementLayout };
//# sourceMappingURL=useElementLayout.mjs.map
