const getBoundingClientRect = (node) => {
  if (!(!node || node.nodeType !== 1))
    return node.getBoundingClientRect?.();
}, getBoundingClientRectAsync = (element) => new Promise((resolve) => {
  let didFallback = !1;
  function fallbackToSync() {
    didFallback = !0, resolve(getBoundingClientRect(element));
  }
  const tm = setTimeout(fallbackToSync, 32);
  new IntersectionObserver(
    (entries, ob) => {
      clearTimeout(tm), ob.disconnect(), didFallback || resolve(entries[0]?.boundingClientRect);
    },
    {
      threshold: 1e-4
    }
  ).observe(element);
});
export {
  getBoundingClientRect,
  getBoundingClientRectAsync
};
//# sourceMappingURL=getBoundingClientRect.js.map
