var getBoundingClientRect = function (node) {
    var _node_getBoundingClientRect;
    if (!(!node || node.nodeType !== 1)) return (_node_getBoundingClientRect = node.getBoundingClientRect) === null || _node_getBoundingClientRect === void 0 ? void 0 : _node_getBoundingClientRect.call(node);
  },
  getBoundingClientRectAsync = function (element) {
    return new Promise(function (resolve) {
      var didFallback = !1;
      function fallbackToSync() {
        didFallback = !0, resolve(getBoundingClientRect(element));
      }
      var tm = setTimeout(fallbackToSync, 32),
        observer = new IntersectionObserver(function (entries, ob) {
          if (clearTimeout(tm), ob.disconnect(), !didFallback) {
            var _entries_;
            resolve((_entries_ = entries[0]) === null || _entries_ === void 0 ? void 0 : _entries_.boundingClientRect);
          }
        }, {
          threshold: 1e-4
        });
      observer.observe(element);
    });
  };
export { getBoundingClientRect, getBoundingClientRectAsync };
//# sourceMappingURL=getBoundingClientRect.native.js.map
