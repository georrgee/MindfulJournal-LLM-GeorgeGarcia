"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var useElementLayout_exports = {};
__export(useElementLayout_exports, {
  getElementLayoutEvent: () => getElementLayoutEvent,
  getElementLayoutEventAsync: () => getElementLayoutEventAsync,
  measureLayout: () => measureLayout,
  measureLayoutAsync: () => measureLayoutAsync,
  setOnLayoutStrategy: () => setOnLayoutStrategy,
  useElementLayout: () => useElementLayout
});
module.exports = __toCommonJS(useElementLayout_exports);
var import_constants = require("@tamagui/constants"), import_web = require("@tamagui/web"), LayoutHandlers = /* @__PURE__ */ new WeakMap(), Nodes = /* @__PURE__ */ new Set(), strategy = "async";
function setOnLayoutStrategy(state) {
  strategy = state;
}
var NodeRectCache = /* @__PURE__ */ new WeakMap(), ParentRectCache = /* @__PURE__ */ new WeakMap(), DebounceTimers = /* @__PURE__ */ new WeakMap(), LastChangeTime = /* @__PURE__ */ new WeakMap(), rAF = typeof window < "u" ? window.requestAnimationFrame : void 0, DEBOUNCE_DELAY = 32;
if (import_constants.isClient)
  if (rAF) {
    let layoutOnAnimationFrame = function() {
      var now = Date.now(), timeSinceLastFrame = now - lastFrameAt;
      if (lastFrameAt = now, strategy !== "off") {
        var expectedFrameTime = 16.67, hasRecentSyncWork = timeSinceLastFrame > expectedFrameTime * numDroppedFramesUntilPause;
        hasRecentSyncWork || Nodes.forEach(updateLayoutIfChanged);
      }
      rAF(layoutOnAnimationFrame);
    };
    var layoutOnAnimationFrame2 = layoutOnAnimationFrame, avoidUpdates = !0, queuedUpdates = /* @__PURE__ */ new Map(), lastFrameAt = Date.now(), numDroppedFramesUntilPause = 2;
    (0, import_web.___onDidFinishClientRender)(function() {
      avoidUpdates = !1, queuedUpdates && (queuedUpdates.forEach(function(cb) {
        return cb();
      }), queuedUpdates.clear());
    });
    async function updateLayoutIfChanged(node) {
      var nodeRect = node.getBoundingClientRect(), parentNode = node.parentElement, parentRect = parentNode == null ? void 0 : parentNode.getBoundingClientRect(), onLayout = LayoutHandlers.get(node);
      if (typeof onLayout == "function") {
        var cachedRect = NodeRectCache.get(node), cachedParentRect = parentNode ? NodeRectCache.get(parentNode) : null;
        if (!cachedRect || // has changed one rect
        !(0, import_web.isEqualShallow)(cachedRect, nodeRect) && (!cachedParentRect || !(0, import_web.isEqualShallow)(cachedParentRect, parentRect)))
          if (NodeRectCache.set(node, nodeRect), parentRect && parentNode && ParentRectCache.set(parentNode, parentRect), avoidUpdates) {
            var event = getElementLayoutEvent(node);
            queuedUpdates.set(node, function() {
              return onLayout(event);
            });
          } else if (strategy === "async") {
            var now = Date.now();
            LastChangeTime.set(node, now);
            var existingTimer = DebounceTimers.get(node);
            existingTimer && clearTimeout(existingTimer);
            var timer = setTimeout(async function() {
              var lastChange = LastChangeTime.get(node) || 0, timeSinceChange = Date.now() - lastChange;
              if (timeSinceChange >= DEBOUNCE_DELAY) {
                var event2 = await getElementLayoutEventAsync(node);
                onLayout(event2), DebounceTimers.delete(node);
              } else {
                var remainingDelay = DEBOUNCE_DELAY - timeSinceChange, newTimer = setTimeout(async function() {
                  var event3 = await getElementLayoutEventAsync(node);
                  onLayout(event3), DebounceTimers.delete(node);
                }, remainingDelay);
                DebounceTimers.set(node, newTimer);
              }
            }, DEBOUNCE_DELAY);
            DebounceTimers.set(node, timer);
          } else {
            var event1 = getElementLayoutEvent(node);
            onLayout(event1);
          }
      }
    }
    rAF(layoutOnAnimationFrame);
  } else
    process.env.NODE_ENV === "development" && console.warn("No requestAnimationFrame - please polyfill for onLayout to work correctly");
var getElementLayoutEvent = function(target) {
  var res = null;
  if (measureLayout(target, null, function(x, y, width, height, left, top) {
    res = {
      nativeEvent: {
        layout: {
          x,
          y,
          width,
          height,
          left,
          top
        },
        target
      },
      timeStamp: Date.now()
    };
  }), !res)
    throw new Error("\u203C\uFE0F");
  return res;
}, measureLayout = function(node, relativeTo, callback) {
  var relativeNode = relativeTo || (node == null ? void 0 : node.parentElement);
  if (relativeNode instanceof HTMLElement) {
    var nodeDim = node.getBoundingClientRect(), relativeNodeDim = relativeNode.getBoundingClientRect();
    if (relativeNodeDim && nodeDim) {
      var { x, y, width, height, left, top } = getRelativeDimensions(nodeDim, relativeNodeDim);
      callback(x, y, width, height, left, top);
    }
  }
}, getElementLayoutEventAsync = async function(target) {
  var res = null;
  if (await measureLayoutAsync(target, null, function(x, y, width, height, left, top) {
    res = {
      nativeEvent: {
        layout: {
          x,
          y,
          width,
          height,
          left,
          top
        },
        target
      },
      timeStamp: Date.now()
    };
  }), !res)
    throw new Error("\u203C\uFE0F");
  return res;
}, measureLayoutAsync = async function(node, relativeTo, callback) {
  var relativeNode = relativeTo || (node == null ? void 0 : node.parentElement);
  if (relativeNode instanceof HTMLElement) {
    var [nodeDim, relativeNodeDim] = await Promise.all([
      node.getBoundingClientRect(),
      relativeNode.getBoundingClientRect()
    ]);
    if (relativeNodeDim && nodeDim) {
      var { x, y, width, height, left, top } = getRelativeDimensions(nodeDim, relativeNodeDim);
      callback(x, y, width, height, left, top);
    }
  }
}, getRelativeDimensions = function(a, b) {
  var { height, left, top, width } = a, x = left - b.left, y = top - b.top;
  return {
    x,
    y,
    width,
    height,
    left,
    top
  };
};
function useElementLayout(ref, onLayout) {
  var _ref_current, node = (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.host;
  node && onLayout && LayoutHandlers.set(node, onLayout), (0, import_constants.useIsomorphicLayoutEffect)(function() {
    var _ref_current2;
    if (onLayout) {
      var node2 = (_ref_current2 = ref.current) === null || _ref_current2 === void 0 ? void 0 : _ref_current2.host;
      if (node2)
        return LayoutHandlers.set(node2, onLayout), Nodes.add(node2), onLayout(getElementLayoutEvent(node2)), function() {
          Nodes.delete(node2), LayoutHandlers.delete(node2), NodeRectCache.delete(node2);
          var timer = DebounceTimers.get(node2);
          timer && (clearTimeout(timer), DebounceTimers.delete(node2)), LastChangeTime.delete(node2);
        };
    }
  }, [
    ref,
    !!onLayout
  ]);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getElementLayoutEvent,
  getElementLayoutEventAsync,
  measureLayout,
  measureLayoutAsync,
  setOnLayoutStrategy,
  useElementLayout
});
//# sourceMappingURL=useElementLayout.js.map
